// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: videos.sql

package db

import (
	"context"
	"time"
)

const createVideo = `-- name: CreateVideo :execlastid
insert into videos (user_id, title, play_url, cover_url)
values (?, ?, ?, ?)
`

type CreateVideoParams struct {
	UserID   int64  `json:"user_id"`
	Title    string `json:"title"`
	PlayUrl  string `json:"play_url"`
	CoverUrl string `json:"cover_url"`
}

func (q *Queries) CreateVideo(ctx context.Context, arg CreateVideoParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createVideo,
		arg.UserID,
		arg.Title,
		arg.PlayUrl,
		arg.CoverUrl,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteVideo = `-- name: DeleteVideo :exec
delete
from videos
where id = ?
`

func (q *Queries) DeleteVideo(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteVideo, id)
	return err
}

const getVideoByID = `-- name: GetVideoByID :one
select videos.id,
       title,
       play_url,
       cover_url,
       favorite_count,
       comment_count,
       created_at,
       user.id as user_id,
       name,
       follow_count,
       follower_count
from videos,
     user
where videos.id = ?
  and videos.user_id = user.id
limit 1
`

type GetVideoByIDRow struct {
	ID            int64     `json:"id"`
	Title         string    `json:"title"`
	PlayUrl       string    `json:"play_url"`
	CoverUrl      string    `json:"cover_url"`
	FavoriteCount int64     `json:"favorite_count"`
	CommentCount  int64     `json:"comment_count"`
	CreatedAt     time.Time `json:"created_at"`
	UserID        int64     `json:"user_id"`
	Name          string    `json:"name"`
	FollowCount   int64     `json:"follow_count"`
	FollowerCount int64     `json:"follower_count"`
}

func (q *Queries) GetVideoByID(ctx context.Context, id int64) (GetVideoByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getVideoByID, id)
	var i GetVideoByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.PlayUrl,
		&i.CoverUrl,
		&i.FavoriteCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UserID,
		&i.Name,
		&i.FollowCount,
		&i.FollowerCount,
	)
	return i, err
}

const getVideosByDate = `-- name: GetVideosByDate :many
select videos.id,
       title,
       play_url,
       cover_url,
       favorite_count,
       comment_count,
       created_at,
       user.id                                        as user_id,
       name,
       follow_count,
       follower_count,
       exists(select id, user_id, video_id
              from user_videos
              where user_videos.user_id = ?
                and user_videos.video_id = videos.id) as is_favorite_video,
       exists(select id, from_id, to_id from user_followers where user_followers.from_id = ? and user_followers.to_id = videos.user_id
           )                                          as is_favorite_user
from videos,
     user
where videos.created_at <= ?
  and videos.user_id = user.id
order by videos.created_at desc
limit ?
`

type GetVideosByDateParams struct {
	UserID    int64     `json:"user_id"`
	FromID    int64     `json:"from_id"`
	CreatedAt time.Time `json:"created_at"`
	Limit     int32     `json:"limit"`
}

type GetVideosByDateRow struct {
	ID              int64     `json:"id"`
	Title           string    `json:"title"`
	PlayUrl         string    `json:"play_url"`
	CoverUrl        string    `json:"cover_url"`
	FavoriteCount   int64     `json:"favorite_count"`
	CommentCount    int64     `json:"comment_count"`
	CreatedAt       time.Time `json:"created_at"`
	UserID          int64     `json:"user_id"`
	Name            string    `json:"name"`
	FollowCount     int64     `json:"follow_count"`
	FollowerCount   int64     `json:"follower_count"`
	IsFavoriteVideo bool      `json:"is_favorite_video"`
	IsFavoriteUser  bool      `json:"is_favorite_user"`
}

func (q *Queries) GetVideosByDate(ctx context.Context, arg GetVideosByDateParams) ([]GetVideosByDateRow, error) {
	rows, err := q.db.QueryContext(ctx, getVideosByDate,
		arg.UserID,
		arg.FromID,
		arg.CreatedAt,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVideosByDateRow{}
	for rows.Next() {
		var i GetVideosByDateRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.PlayUrl,
			&i.CoverUrl,
			&i.FavoriteCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UserID,
			&i.Name,
			&i.FollowCount,
			&i.FollowerCount,
			&i.IsFavoriteVideo,
			&i.IsFavoriteUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVideosByUserID = `-- name: GetVideosByUserID :many
select videos.id,
       title,
       play_url,
       cover_url,
       favorite_count,
       comment_count,
       created_at,
       user.id                                        as user_id,
       name,
       follow_count,
       follower_count,
       exists(select id, user_id, video_id
              from user_videos
              where user_videos.user_id = ?
                and user_videos.video_id = videos.id) as is_favorite_video,
       exists(select id, from_id, to_id from user_followers where user_followers.from_id = ? and user_followers.to_id = videos.user_id
           )                                          as is_favorite_user
from videos,
     user
where videos.user_id = ?
  and videos.user_id = user.id
order by videos.created_at desc
`

type GetVideosByUserIDParams struct {
	UserID   int64 `json:"user_id"`
	FromID   int64 `json:"from_id"`
	UserID_2 int64 `json:"user_id_2"`
}

type GetVideosByUserIDRow struct {
	ID              int64     `json:"id"`
	Title           string    `json:"title"`
	PlayUrl         string    `json:"play_url"`
	CoverUrl        string    `json:"cover_url"`
	FavoriteCount   int64     `json:"favorite_count"`
	CommentCount    int64     `json:"comment_count"`
	CreatedAt       time.Time `json:"created_at"`
	UserID          int64     `json:"user_id"`
	Name            string    `json:"name"`
	FollowCount     int64     `json:"follow_count"`
	FollowerCount   int64     `json:"follower_count"`
	IsFavoriteVideo bool      `json:"is_favorite_video"`
	IsFavoriteUser  bool      `json:"is_favorite_user"`
}

func (q *Queries) GetVideosByUserID(ctx context.Context, arg GetVideosByUserIDParams) ([]GetVideosByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getVideosByUserID, arg.UserID, arg.FromID, arg.UserID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVideosByUserIDRow{}
	for rows.Next() {
		var i GetVideosByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.PlayUrl,
			&i.CoverUrl,
			&i.FavoriteCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UserID,
			&i.Name,
			&i.FollowCount,
			&i.FollowerCount,
			&i.IsFavoriteVideo,
			&i.IsFavoriteUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVideosByUserVideo = `-- name: GetVideosByUserVideo :many
select videos.id,
       title,
       play_url,
       cover_url,
       favorite_count,
       comment_count,
       created_at,
       user.id as user_id,
       name,
       follow_count,
       follower_count
from videos,
     user,
     user_videos
where user_videos.user_id = ?
  and videos.id = user_videos.video_id
  and user.id = videos.user_id
order by user_videos.id desc
`

type GetVideosByUserVideoRow struct {
	ID            int64     `json:"id"`
	Title         string    `json:"title"`
	PlayUrl       string    `json:"play_url"`
	CoverUrl      string    `json:"cover_url"`
	FavoriteCount int64     `json:"favorite_count"`
	CommentCount  int64     `json:"comment_count"`
	CreatedAt     time.Time `json:"created_at"`
	UserID        int64     `json:"user_id"`
	Name          string    `json:"name"`
	FollowCount   int64     `json:"follow_count"`
	FollowerCount int64     `json:"follower_count"`
}

func (q *Queries) GetVideosByUserVideo(ctx context.Context, userID int64) ([]GetVideosByUserVideoRow, error) {
	rows, err := q.db.QueryContext(ctx, getVideosByUserVideo, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVideosByUserVideoRow{}
	for rows.Next() {
		var i GetVideosByUserVideoRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.PlayUrl,
			&i.CoverUrl,
			&i.FavoriteCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UserID,
			&i.Name,
			&i.FollowCount,
			&i.FollowerCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVideoCommentCount = `-- name: UpdateVideoCommentCount :exec
update videos
set comment_count = comment_count + ?
where id = ?
`

type UpdateVideoCommentCountParams struct {
	CommentCount int64 `json:"comment_count"`
	ID           int64 `json:"id"`
}

func (q *Queries) UpdateVideoCommentCount(ctx context.Context, arg UpdateVideoCommentCountParams) error {
	_, err := q.db.ExecContext(ctx, updateVideoCommentCount, arg.CommentCount, arg.ID)
	return err
}

const updateVideoFavoriteCount = `-- name: UpdateVideoFavoriteCount :exec
update videos
set favorite_count = favorite_count +/**/ ?
where id = ?
`

type UpdateVideoFavoriteCountParams struct {
	FavoriteCount int64 `json:"favorite_count"`
	ID            int64 `json:"id"`
}

func (q *Queries) UpdateVideoFavoriteCount(ctx context.Context, arg UpdateVideoFavoriteCountParams) error {
	_, err := q.db.ExecContext(ctx, updateVideoFavoriteCount, arg.FavoriteCount, arg.ID)
	return err
}
